use core::{fmt::Debug, time::Duration};
use std::net::SocketAddr;
use std::path::{Path, PathBuf};
use std::str;
use std::sync::Arc;

use anyhow::{anyhow, Context, Result};
use async_trait::async_trait;
use bytes::{Buf, BufMut};
use serde::{Deserialize, Serialize};
use tokio::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};
use tokio::net::{TcpListener, TcpStream, UdpSocket};
use tokio::sync::Mutex;
use tokio::time::sleep;
use tokio_rustls::rustls::server::{AllowAnyAuthenticatedClient, NoClientAuth};
use tokio_rustls::rustls::{Certificate, ClientConfig, PrivateKey, RootCertStore, ServerConfig};
use tokio_rustls::{server::TlsStream, TlsAcceptor};

//
// Message

/// Network message
pub trait Message: Serialize + for<'a> Deserialize<'a> + Debug + Send + 'static {
    const PACKET_TYPE: u32;

    /// Converts to packet containing UTF-8 encoded JSON string
    fn to_packet(&self) -> Packet {
        let payload = serde_json::to_string(self)
            .expect("never happens")
            .as_bytes()
            .to_vec();
        Packet::new(Self::PACKET_TYPE, payload)
    }

    /// Interprets packet payload as UTF-8 encoded JSON string
    //
    /// # Errors
    /// - payload is not valid UTF-8 string
    /// - payload is not valid JSON
    /// - payload is not generated by [`Message::to_packet`]
    fn from_packet(packet: &Packet) -> Result<Self> {
        if packet.ty == Self::PACKET_TYPE {
            serde_json::from_str(packet.as_str()?).context("Invalid JSON")
        } else {
            Err(anyhow!("Unknown packet type"))
        }
    }
}

//
// MessageTransmitter, JsonTransmitter

/// Sends [`Message`]s
#[async_trait]
pub trait MessageTransmitter: Send + Clone + 'static {
    async fn send<M: Message>(&self, message: M) -> Result<()>;
}

/// Sends [`Message`]s in JSON
#[must_use]
#[derive(Clone)]
pub struct JsonTransmitter<T: Transmitter> {
    transmitter: T,
}

impl<T: Transmitter> JsonTransmitter<T> {
    pub fn new(transmitter: T) -> JsonTransmitter<T> {
        JsonTransmitter { transmitter }
    }
}

#[async_trait]
impl<T: Transmitter> MessageTransmitter for JsonTransmitter<T> {
    async fn send<M: Message>(&self, message: M) -> Result<()> {
        let packet = message.to_packet();
        self.transmitter.send(packet).await
    }
}

//
// Packet

/// Network packet
#[must_use]
pub struct Packet {
    ty: u32,
    payload: Vec<u8>,
}

impl Packet {
    const MAX_SIZE: usize = 0x10000 - 4 * 2;

    /// Writes packet to `target`
    ///
    /// # Errors
    /// - Target write error
    pub async fn write<T: AsyncWrite + Unpin>(&self, target: &mut T) -> Result<()> {
        target.write_u32(self.payload.len() as u32).await?;
        target.write_u32(self.ty).await?;
        target.write_all(&self.payload).await?;
        target.flush().await?;
        Ok(())
    }

    /// Reads packet from `source`
    ///
    /// # Errors
    /// - Source read error
    /// - Invalid packet layout
    pub async fn read<S: AsyncRead + Unpin>(source: &mut S) -> Result<Packet> {
        let size = source.read_u32().await? as usize;
        if size > Self::MAX_SIZE {
            return Err(anyhow!("Packet too large"));
        }

        let ty = source.read_u32().await?;

        let mut payload = vec![0; size];
        source.read_exact(&mut payload).await?;

        Ok(Self::new(ty, payload))
    }

    fn new(ty: u32, payload: Vec<u8>) -> Packet {
        Packet { ty, payload }
    }

    /// Receives packet via UDP
    ///
    /// # Errors
    /// - UDP receive error
    /// - Invalid packet layout
    #[allow(clippy::indexing_slicing)]
    pub async fn receive(socket: &UdpSocket) -> Result<(Packet, SocketAddr)> {
        let mut buffer = [0; Packet::MAX_SIZE + 8];
        let (len, address) = socket.recv_from(&mut buffer).await?;
        if len >= 8 && len - 8 == (&buffer[..4]).get_u32() as usize {
            let packet = Self::new((&buffer[4..8]).get_u32(), buffer[8..len].to_vec());
            Ok((packet, address))
        } else {
            Err(anyhow!("Size mismatch"))
        }
    }

    /// Sends packet via UDP
    ///
    /// # Errors
    /// - UDP send error
    pub async fn send(&self, socket: &UdpSocket, addr: &SocketAddr) -> Result<()> {
        let mut data = Vec::with_capacity(8 + self.payload.len());
        data.put_u32(self.payload.len() as u32);
        data.put_u32(self.ty);
        data.put_slice(&self.payload);
        socket.send_to(&data, addr).await?;
        Ok(())
    }

    /// Interprets payload as UTF-8 encoded string
    //
    /// # Errors
    /// - input is not valid UTF-8 string
    pub fn as_str(&self) -> Result<&str> {
        str::from_utf8(&self.payload).context("Invalid UTF-8")
    }

    /// Returns packet type
    #[must_use]
    pub fn ty(&self) -> u32 {
        self.ty
    }
}

//
// Receiver, Transmitter

/// Receives [`Packet`]s
#[async_trait]
pub trait Receiver<T: Transmitter>: Send + 'static {
    async fn receive(&mut self) -> Result<(Packet, T)>;
}

/// Sends [`Packet`]s
#[async_trait]
pub trait Transmitter: Send + Sync + Unpin + Clone + 'static {
    async fn send(&self, packet: Packet) -> Result<()>;
}

#[async_trait]
impl<T: AsyncWrite + Send + Unpin + 'static> Transmitter for Arc<Mutex<T>> {
    async fn send(&self, packet: Packet) -> Result<()> {
        packet.write(&mut *self.lock().await).await
    }
}

//
// UdpStream, UdpReceiver

/// UDP pseudo-stream
#[derive(Clone)]
#[must_use]
pub struct UdpStream {
    socket: Arc<UdpSocket>,
    address: SocketAddr,
}

impl UdpStream {
    fn new(socket: Arc<UdpSocket>, address: SocketAddr) -> UdpStream {
        UdpStream { socket, address }
    }
}

#[async_trait]
impl Transmitter for UdpStream {
    async fn send(&self, packet: Packet) -> Result<()> {
        packet.send(&self.socket, &self.address).await
    }
}

/// Receives [`Packet`]s over UDP
#[must_use]
pub struct UdpReceiver {
    socket: Arc<UdpSocket>,
}

impl UdpReceiver {
    /// Creates an UDP receiver
    ///
    /// # Errors
    /// - Cannot bind to `socket_address`
    pub async fn new(socket_address: &SocketAddr) -> Result<Self> {
        Ok(Self {
            socket: Arc::new(UdpSocket::bind(socket_address).await?),
        })
    }
}

#[async_trait]
impl Receiver<UdpStream> for UdpReceiver {
    async fn receive(&mut self) -> Result<(Packet, UdpStream)> {
        Box::pin(Packet::receive(&self.socket))
            .await
            .map(|(packet, address)| (packet, UdpStream::new(Arc::clone(&self.socket), address)))
    }
}

//
// TcpReceiver

/// Receives [`Packet`]s over TCP
#[must_use]
pub struct TcpReceiver {
    listener: Arc<TcpListener>,
}

impl TcpReceiver {
    /// Creates TCP receiver
    ///
    /// # Errors
    /// - Cannot bind to `socket_address`
    pub async fn new(socket_address: &SocketAddr) -> Result<Self> {
        Ok(Self {
            listener: Arc::new(TcpListener::bind(socket_address).await?),
        })
    }
}

#[async_trait]
impl Receiver<Arc<Mutex<TcpStream>>> for TcpReceiver {
    async fn receive(&mut self) -> Result<(Packet, Arc<Mutex<TcpStream>>)> {
        // Self::spawn(
        //     "TCP connection",
        //     async move { this.communicate(stream).await },
        // );
        let (mut stream, _addr) = self.listener.accept().await.context("accept")?;
        Ok((
            Packet::read(&mut stream).await?,
            Arc::new(Mutex::new(stream)),
        ))
    }
}

//
// TlsAuth, TlsServiceConfig, TlsClientConfig, TlsReceiver

/// Authentication pair: key and certificate chain
#[derive(Debug, Serialize, Deserialize)]
#[must_use]
pub struct TlsAuth {
    #[serde(alias = "private-key")]
    private_key: PathBuf,
    certificate: PathBuf,
}

impl TlsAuth {
    pub fn new(key: &Path, certificate: &Path) -> Self {
        Self {
            private_key: key.to_owned(),
            certificate: certificate.to_owned(),
        }
    }

    fn load_key(&self) -> Result<PrivateKey> {
        TlsUtil::load_key(&self.private_key)
    }

    fn load_certificates(&self) -> Result<Vec<Certificate>> {
        TlsUtil::load_certificates(&self.certificate)
    }

    pub fn resolve_paths(&mut self, base: &Path) {
        self.private_key = base.join(&self.private_key);
        self.certificate = base.join(&self.certificate);
    }
}

/// TLS server configuration
#[derive(Debug, Serialize, Deserialize)]
#[must_use]
pub struct TlsServerConfig {
    #[serde(flatten)]
    server_auth: TlsAuth,
    #[serde(alias = "client-auth")]
    client_certificates: Option<PathBuf>,
}

impl TlsServerConfig {
    pub fn new(server_key: &Path, server_certificates: &Path, client_auth: Option<&Path>) -> Self {
        TlsServerConfig {
            server_auth: TlsAuth::new(server_key, server_certificates),
            client_certificates: client_auth.map(Path::to_owned),
        }
    }

    fn acceptor(&self) -> Result<TlsAcceptor> {
        Ok(TlsAcceptor::from(Arc::new(self.config()?)))
    }

    fn config(&self) -> Result<ServerConfig> {
        let auth = &self.server_auth;
        ServerConfig::builder()
            .with_safe_defaults()
            .with_client_cert_verifier(match self.client_certificates.as_ref() {
                None => Ok(NoClientAuth::boxed()) as Result<_>,
                Some(path) => {
                    Ok(AllowAnyAuthenticatedClient::new(TlsUtil::load_root_cert(path)?).boxed())
                }
            }?)
            .with_single_cert(auth.load_certificates()?, auth.load_key()?)
            .context("Invalid private key")
    }

    pub fn resolve_paths(&mut self, base: &Path) {
        self.server_auth.resolve_paths(base);
        self.client_certificates
            .iter_mut()
            .for_each(|path| *path = base.join(&path));
    }
}

/// TLS client configuration
#[must_use]
pub struct TlsClientConfig {
    server_certificates: PathBuf,
    client_auth: Option<TlsAuth>,
}

impl TlsClientConfig {
    pub fn new(server_certificates: &Path, client_auth: Option<TlsAuth>) -> Self {
        Self {
            server_certificates: server_certificates.to_owned(),
            client_auth,
        }
    }

    /// Build [`ClientConfig`]
    ///
    /// # Errors
    /// - Cannot load server certificates
    /// - Cannot load client auth key or certificates
    pub fn config(&self) -> Result<ClientConfig> {
        let builder = ClientConfig::builder()
            .with_safe_defaults()
            .with_root_certificates(TlsUtil::load_root_cert(&self.server_certificates)?);
        match self.client_auth {
            None => Ok(builder.with_no_client_auth()),
            Some(ref auth) => builder
                .with_client_auth_cert(auth.load_certificates()?, auth.load_key()?)
                .context("Client auth"),
        }
    }
}

struct TlsUtil;

impl TlsUtil {
    fn load_key(path: &Path) -> Result<PrivateKey> {
        rustls_pemfile::pkcs8_private_keys(&mut Self::open(path, "Private key")?)
            .context(format!("Invalid key file {path:?}"))
            .and_then(|keys| match keys.len() {
                0 => Err(anyhow!("No private keys found in {path:?}")),
                1 => Ok(PrivateKey(keys.into_iter().next().expect("index checked"))),
                _ => Err(anyhow!("Multiple private keys found in {path:?}")),
            })
    }

    fn load_certificates(path: &Path) -> Result<Vec<Certificate>> {
        rustls_pemfile::certs(&mut Self::open(path, "Certificates file")?)
            .context(format!("Invalid certificates file {path:?}"))
            .and_then(|certs| match certs.len() {
                0 => Err(anyhow!("No certificates found in {path:?}")),
                _ => Ok(certs.into_iter().map(Certificate).collect()),
            })
    }

    fn open(path: &Path, context: &str) -> Result<std::io::BufReader<std::fs::File>> {
        let file = std::fs::File::open(path).context(format!("{context} {path:?} not found"))?;
        Ok(std::io::BufReader::new(file))
    }

    fn load_root_cert(path: &Path) -> Result<RootCertStore> {
        let mut root_cert_store = RootCertStore::empty();
        for certificate in Self::load_certificates(path)? {
            root_cert_store.add(&certificate)?;
        }
        Ok(root_cert_store)
    }
}

pub struct TlsListener {
    acceptor: TlsAcceptor,
    listener: TcpListener,
}

impl TlsListener {
    /// Creates a new TLS listener
    ///
    /// # Errors
    /// Error error if
    /// - `config` is invalid
    /// - cannot bind to specified `socket_address`
    pub async fn new(socket_address: &SocketAddr, config: &TlsServerConfig) -> Result<Self> {
        Ok(Self {
            acceptor: config.acceptor()?,
            listener: TcpListener::bind(&socket_address).await?,
        })
    }

    /// Accepts a new TLS connection
    ///
    /// # Errors
    /// Error error if
    /// - `config` is invalid
    /// - cannot bind to specified `socket_address`
    pub async fn accept(&mut self) -> Result<(TlsTransmitter, SocketAddr)> {
        let (tcp_stream, addr) = self.listener.accept().await.context("accept")?;
        // Self::spawn(
        //     "TLS connection",
        //     async move { this.communicate(stream).await },
        // );
        let transmitter = TlsTransmitter {
            stream: Some(self.acceptor.accept(tcp_stream).await?),
        };
        Ok((transmitter, addr))
    }
}

/// Receives [`Packet`]s over TLS
#[must_use]
pub struct TlsReceiver {
    listener: TlsListener,
}

impl TlsReceiver {
    /// Creates a new TLS receiver
    ///
    /// # Errors
    /// Error error if
    /// - `config` is invalid
    /// - cannot bind to specified `socket_address`
    pub async fn new(socket_address: &SocketAddr, config: &TlsServerConfig) -> Result<Self> {
        Ok(Self {
            listener: TlsListener::new(socket_address, config).await?,
        })
    }
}

#[async_trait]
impl Receiver<Arc<Mutex<TlsTransmitter>>> for TlsReceiver {
    async fn receive(&mut self) -> Result<(Packet, Arc<Mutex<TlsTransmitter>>)> {
        let (mut transmitter, _addr) = self.listener.accept().await?;
        let packet = Packet::read(transmitter.stream()).await?;
        Ok((packet, Arc::new(Mutex::new(transmitter))))
    }
}

pub struct TlsTransmitter {
    stream: Option<TlsStream<TcpStream>>,
}

impl TlsTransmitter {
    pub fn stream(&mut self) -> &mut TlsStream<TcpStream> {
        self.stream.as_mut().expect("not drop")
    }
}

#[async_trait]
impl Transmitter for Arc<Mutex<TlsTransmitter>> {
    async fn send(&self, packet: Packet) -> Result<()> {
        packet.write(self.lock().await.stream()).await
    }
}

impl Drop for TlsTransmitter {
    fn drop(&mut self) {
        const JAVA_SLEEP: Duration = Duration::from_millis(1);

        let mut stream = self.stream.take().expect("not drop");
        tokio::spawn(async move {
            stream.shutdown().await.expect("shutdown socket");

            // Java TLS compatibility
            sleep(JAVA_SLEEP).await;
        });
    }
}
